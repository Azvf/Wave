# AI 辅助开发通用规范指南
## Universal AI-Assisted Engineering Guidelines

> ⚠️ **文档已模块化拆解**: 本文档已拆分为多个模块文档。建议使用 [文档索引](./文档索引.md) 访问模块化的文档版本，以获得更好的导航和维护性。

> **适用范围**: 架构无关、业务无关、语言无关的通用 AI 辅助开发规范

**核心理念**: 本规范将 AI 视为团队中的"数字员工"进行管理，对其权限、职责、思考方式和工作流进行严格界定。它不仅仅是一份技术指南，更是一套管理制度，将 Tech Lead 的隐性知识显性化为 AI 可执行的指令，实现从"工具配置"到"数字员工管理"的进化。

---

## 目录

1. [架构策略：模块化与关注点分离](#1-架构策略模块化与关注点分离)
2. [交互协议：标准化与特权分级](#2-交互协议标准化与特权分级)
3. [质量控制：思维链协议与防御性编程](#3-质量控制思维链协议与防御性编程)
4. [通用治理模式](#4-通用治理模式)
5. [规则维护与注意事项](#5-规则维护与注意事项)

---

## 1. 架构策略：模块化与关注点分离

### 1.1 核心原则

**彻底摒弃"单文件万能 Prompt"的草莽模式，采用类似操作系统内核的"微内核 + 插件化"架构设计。**

- **微内核策略**: 全局配置文件仅保留"宪法大纲"（语言、核心人设、代码洁癖）
- **插件化策略**: 利用上下文感知能力，通过文件路径物理隔离规则，降低 Prompt 复杂度与冲突概率

### 1.2 架构设计

#### 微内核（全局配置）

**角色定位**: 全局兜底 (Global Fallback)

**设计原则**:
- **体积控制**: 建议控制在 50 行以内（软性最佳实践）
- **内容限制**: 仅保留全项目通用的指令
- **关注点**: 语言设定、核心人设、代码美学、思考习惯

**为什么建议 < 50 行？**
1. **Token 经济性**: 全局配置内容会被注入到每一次对话的 System Prompt 中，保持极简降低开销
2. **注意力分配**: LLM 的注意力是稀缺资源，避免"中间迷失"现象，将注意力集中在当前上下文
3. **避免规则冲突**: 全局规则权重通常很高，过于细化的全局规则可能干扰特定场景的局部规则

**弹性区间**: 🟢 30-60 行（完美）| 🟡 60-100 行（可接受）| 🔴 > 200 行（反模式）

#### 插件化（领域规则）

**角色定位**: 领域特定的原子化规则

**设计原则**:
- **按领域拆分**: 每个规则文件只包含真正必要的内容
- **智能挂载**: 利用上下文感知能力（文件路径、文件类型）自动挂载
- **物理隔离**: 通过文件路径匹配，避免规则冲突

**挂载策略** (Globs Strategy):

| 规则类型 | 职责 | 挂载策略 | 示例 |
|---------|------|---------|------|
| **层级规则** | 物理架构约束 | 按目录匹配 | `src/core/**/*` (禁止依赖上层) |
| **技术栈规则** | 特定框架规范 | 按扩展名匹配 | `**/*.tsx` (UI), `**/*.sql` (DB) |
| **工作流规则** | 强制流程拦截 | 语义触发 | `Agent Trigger: Create component...` |
| **工程规则** | 质量与工具链 | 全局代码文件 | `**/*.ts`, `config/**/*` |

### 1.3 规则文件结构

每个领域规则文件应遵循标准结构：

```markdown
---
description: [动词开头] 简述规则作用
globs: [文件路径匹配模式]
alwaysApply: false
---

# [Domain Name] Architecture

## 1. Persona & Context (角色定位)
*定义该领域的专家身份及核心关注点（Top 3 Priorities）*

## 2. Documentation Dependencies (知识库索引)
*建立文档的 SSOT（单一真理源），防止 AI 编造信息*

## 3. CoT Protocol (思维链协议)
*强制 Agent 在写代码前输出分析块，根据领域风险采用不同力度*

## 4. Critical Prohibitions (防御性禁令)
*明确的 Negative Constraints*

## 5. Implementation Patterns (最佳实践)
*正向引导的代码模板，消除代码风格差异*
```

---

## 2. 交互协议：标准化与特权分级

### 2.1 核心原则

**建立明确的"指令级路由"，实现标准化与特权分级的平衡。**

### 2.2 标准流程 vs. 特权模式

**标准流程 (Standard Flow)**
- **适用场景**: 创建新功能、结构性重构、复杂变更
- **机制**: 通过语义关键词触发（如 `Create`, `Refactor`），工作流拦截器自动执行前置步骤（测试、文档等）

**特权模式 (Bypass Mode)**
- **适用场景**: 仅修改样式、修复微小 Bug、不涉及结构变更
- **机制**: 通过特定前缀触发（如 `Hotfix:`, `Quick fix:`），跳过强制工作流直接执行修改

### 2.3 语义化指令规范

#### 样式指令：讲"语义"不讲"具体值"

**核心原则**: 禁止直接要求具体的数值（如像素值、颜色值），必须使用语义 Token。维护设计系统完整性，防止 Token 腐烂。

#### 逻辑开发：强调"纯净"与"分层"

**核心原则**: 区分核心逻辑与展示层，强调依赖方向。

**关键词**: `Pure Logic`（核心逻辑层，禁止依赖 UI 框架）、`Headless`（无 UI 依赖的业务逻辑）、`RPC`（跨层通信协议）

### 2.4 问题排查：根本原因分析

**核心原则**: 区分症状与根本原因，进行系统性排查而非表面修复。

**触发关键词**: `Debug:`, `Root cause:`, `Investigate:`, `Trace:`

**排查流程**: 使用语义搜索理解上下文 → 精确搜索追踪数据流 → 检查架构违规 → 分析日志定位源头 → 提供根本原因分析

---

## 3. 质量控制：思维链协议与防御性编程

### 3.1 思维链协议 (CoT Protocol)

#### 核心价值

将架构原则转化为可执行的检查清单，防止 AI 使用"常见但错误"的模式，在代码生成阶段捕获架构违规。

#### 差异化策略：S/M/L 三级 CoT 协议

根据领域风险采用不同力度：

**🔥 L 级 (Large - 必须有，且详细)**
- **适用场景**: 高风险领域（运行时安全、渲染性能、并发控制等）
- **协议内容**: 运行时安全（状态检查、序列化边界、生命周期管理）、渲染性能（层级数量、重绘范围、性能预算）

**🛡️ M 级 (Medium - 推荐有，聚焦边界)**
- **适用场景**: 架构约束、数据一致性、依赖管理
- **协议内容**: 确认层级归属、依赖方向、单一真理源原则

**⚡ S 级 (Small - 可以简化或省略)**
- **适用场景**: 工程配置、文档维护、测试代码
- **策略**: 无需强制 CoT，遵循代码风格即可

#### CoT 设计原则

1. **检查单思维**: 每个检查项对应一个具体的风险点
2. **量化指标**: 使用具体数字（如 "Layer Count > 10"、"Memory > 1MB"）而非模糊描述
3. **差异化策略**: 高风险领域详细分析，低风险领域简化或省略

### 3.2 防御性禁令 (Critical Prohibitions)

**核心原则**: 提供明确的 Negative Constraints，明确禁止的行为。

**设计要点**:
- 使用 `NEVER`, `STRICTLY PROHIBIT`, `MANDATORY` 等强约束词汇
- 针对常见错误模式
- 放在规则文件底部（利用 Recency Effect）

**示例**: `NEVER import UI frameworks from core layer` | `STRICTLY PROHIBIT comments that mirror code` | `MANDATORY: Use design tokens instead of hardcoded values`

### 3.3 实现模式 (Implementation Patterns)

#### 核心价值

"负面禁令"告诉 AI "不要做什么"，"实现模式"告诉 AI "应该怎么做"。消除代码风格差异，提供标准答案，提高一次性通过率。

#### 分级策略：高危区强制，低危区按需

**🔥 必须补充 (Must Have)**: 运行时安全、渲染性能、并发控制等高风险领域。提供代码模板（IPC 调用模式、组件骨架、Token 使用模式）

**🛡️ 推荐补充 (Nice to Have)**: 架构约束、数据一致性、依赖管理等中风险领域。提供标准结构示例（Headless Hook、Repository 模式）

**⚡ 不必强制 (Optional)**: 工程配置、文档维护、测试代码。纯文本规则通常已足够清晰

---

## 4. 通用治理模式

将具体的业务需求抽象为以下四种通用治理模式：

### 4.1 模式 A: 基础设施稳定性协议

**适用场景**: 设计系统 Token、API Client、核心配置等"只读"资源

**核心原则**: 默认只读，组件适配系统，而非系统适配组件

**Prompt**: "Treat [infrastructure file path] as Immutable Infrastructure. NEVER modify existing values to fix local issues."

### 4.2 模式 B: 拦截器工作流

**适用场景**: 组件开发、数据库变更等复杂任务

**核心原则**: 在执行具体代码前，强制插入"中间步骤"（测试、文档、计划等）

**Prompt**: "MANDATORY INTERCEPTOR: When requested to create X, STOP. First generate Y. Only proceed after Y is verified."

### 4.3 模式 C: 纯净性与防腐层

**适用场景**: 核心业务逻辑与外部依赖的隔离

**核心原则**: 核心层严禁依赖 UI 框架或特定运行时 API，保持平台无关性

**Prompt**: "Platform Agnostic: [core layer path] must be pure logic. NEVER import UI frameworks or runtime-specific APIs."

### 4.4 模式 D: 工程卫生

**适用场景**: 注释、文档和临时文件的管理

**核心原则**: 保持高信噪比，禁止冗余注释和临时文件

**Prompt**: "STRICTLY PROHIBIT comments that mirror code. Comment ONLY on 'WHY'. DO NOT generate temporary files in the file system."

---

## 5. 规则维护与注意事项

### 5.1 主要挑战与建议

**规则维护成本**
- **挑战**: 规则文件可能过时，架构变更时未同步更新会导致 AI 生成错误代码
- **建议**: 将规则维护纳入 Code Review 流程，架构变更时同步更新规则

**规则的"过时"风险**
- **挑战**: 规则文件需要随架构变更同步更新，但开发者往往只改代码不改规则。一旦 `.mdc` 文件中的 `Implementation Patterns` 与实际代码库脱节，AI 会持续生成旧版本的代码
- **建议**: 
  - 引入"Rule Linter"或在 CI/CD 流程中增加检查，确保规则文件中的示例代码至少语法正确
  - 定期强制 Review 规则文件，确保与实际代码库保持一致

**拦截器的误杀**
- **挑战**: 依赖于 AI 的理解能力，可能在不需拦截的地方拒绝工作
- **建议**: 明确定义"逃生舱"机制，提供清晰的错误提示和绕过方法

**新人认知负载**
- **挑战**: 开发者需要掌握特定的语义关键词（如 `Pure Logic`, `RPC`, `Trace:`），对新人有一定记忆门槛
- **建议**: 
  - 为团队开发 VS Code / Cursor 的 Snippets 插件（如输入 `/fix` 自动展开为 `Hotfix:`）
  - 提供快速参考卡片（Cheat Sheet），降低记忆负担

**通用性 vs. 专用性**
- **挑战**: 文档标榜为"通用规范"，但使用了 `.cursorrules` 等 Cursor 专用术语。如果团队切换 IDE（如 Windsurf 或 Copilot），需要迁移成本
- **建议**: 
  - 核心思想（上下文管理、分级 CoT）是通用的，可适配不同 AI 辅助工具
  - 考虑将规则核心逻辑抽离为纯 Markdown 文档，以适配不同的工具平台

### 5.2 查漏补缺清单

在设计完规则后，必须检查：共享目录归属、根目录配置、模块的二元性（UI Hooks vs. 业务 Hooks）、测试文件归属、文档文件归属。

### 5.3 提示词工程微技巧

1. **引用即链接**: 提到文档时使用相对路径，让 IDE 可以点击或索引
2. **Recency Effect**: 将最重要的禁令放在规则文件底部，就在 AI 开始写代码之前
3. **语义化触发词**: 在规则文件的 `description` 中堆砌关键词（Trigger Words），提高命中率

---


## 总结

这是一套**企业级、高可维护性**的 AI 辅助开发规范方案。它将 Tech Lead 的 Code Review 标准和架构师的设计原则，通过 Prompt 固化到 IDE 中，实现"代码质量治理左移"。

**核心价值**: 
- **战略高度**: 将 AI 视为"数字员工"进行管理，从"工具配置"进化为"管理制度"，将 Prompt Engineering 从"个人技巧"提升到"工程体系"的高度
- **技术深度**: 深刻理解 **"Context is King"**。通过模块化规则加上标准化交互协议，在有限的 Context Window 中实现对复杂项目的高精度控制

---

**文档版本**: v1.0  
**最后更新**: 基于 Agent-Guide 原始文档整合而成  
**维护原则**: 本规范应随 AI 辅助开发实践的发展而持续演进

