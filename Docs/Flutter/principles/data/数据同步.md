# 数据同步

**核心原则：双模同步 (Dual Mode) · 冲突解决 (Conflict Resolution) · 分布式锁 (Distributed Lock)**

## SyncService 设计

**职责**:
- 调度所有同步任务
- 管理分布式锁（防止多实例并发）
- 实现双模同步（增量 + 全量）

**实现位置**: `lib/core/sync/sync_service.dart`

**实现模式**:
```dart
@riverpod
class SyncService extends _$SyncService {
  Future<void> scheduleSync() async { /* 调度同步任务 */ }
  Future<void> syncNow() async { /* 立即执行同步 */ }
  Future<void> enqueueRetry(String id) async { /* 加入重试队列 */ }
}
```

## 同步模式

- **增量同步**: 基于 `fetchCursor` 时间游标，只拉取变更
- **全量同步**: 周期性或异常时执行完整三路合并

## 软删除机制 (Soft Delete / Tombstones)

**规则**: 离线优先架构中，**严禁物理删除（Hard Delete）**，必须使用软删除。

**实现**:
- 所有 Entity 必须包含 `deletedAt` 字段（DateTime?）
- 删除操作：设置 `deletedAt = DateTime.now()`，不删除记录
- 查询时自动过滤 `deletedAt != null` 的记录

**墓碑传播**:
- 同步时，`deletedAt != null` 的记录作为"墓碑"传播到服务器
- 服务器收到墓碑后，标记远程记录为已删除
- 其他客户端同步时，收到墓碑后本地也标记为删除

**实现位置**: `lib/core/sync/tombstone_handler.dart`

## 冲突解决策略

**简单字段**: Last-Write-Wins (LWW)
- 谁最后修改，采纳谁的值

**复杂字段**: 三路合并 (Three-Way Merge)
- 使用 `ShadowMap` 追踪上次同步状态（Base）
- 对比 Local、Remote、Base 三个版本
- 字段级智能合并：Local 和 Remote 都修改的字段，优先 Remote

**冲突降级**: 无法自动解决时，使用 LWW 策略

**实现位置**: `lib/core/sync/merge_strategy.dart`

## 分布式锁

**规则**: 防止多实例并发同步导致数据冲突。

**实现**:
- 使用 Isar 的原子操作实现锁
- 设置超时时间，防止死锁

详见: [乐观更新](./乐观更新.md) | [离线优先](./离线优先.md)


