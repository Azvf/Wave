# 离线优先

**核心原则：本地写入 (Local Write) · 后台同步 (Background Sync) · 最终一致性 (Eventual Consistency)**

## 设计原则

**规则**: 应用程序必须在无网络环境下具备核心可用性。

**策略**: 数据同步采用 **本地写入 -> 后台同步 -> 最终一致性** 策略。

## 读取策略

**规则**: UI 永远读取 `Isar` 本地数据库流 (`Stream<List<T>>`)。

**小数据量** (< 1000 条):
```dart
@riverpod
Stream<List<Todo>> todoListStream(TodoListStreamRef ref) {
  return ref.watch(todoRepositoryProvider).watchAll();
}
```

**大数据量** (> 1000 条):
- 使用分页加载（Pagination）或懒加载（Lazy Loading）
- 避免 `watchAll()` 全量推送导致 UI 卡顿
- 使用 `Query.watchLazy()` 或手动分页查询

**实现位置**: `lib/features/*/data/repositories/*_repository_impl.dart`

## 写入策略

**规则**: 操作写入 `Isar` -> 触发后台同步任务 (`SyncService`) -> 上传服务器。

**实现**:
```dart
Future<void> createTodo(Todo todo) async {
  // 1. 立即写入本地数据库
  await isar.writeTxn(() async {
    await isar.todos.put(todo);
  });
  
  // 2. 触发后台同步
  ref.read(syncServiceProvider).scheduleSync();
}
```

## 缓存策略 (Stale-While-Revalidate)

**规则**: 我们宁愿显示旧数据，也不显示空白屏幕。

**实现**:
- 页面加载时：立即从 Isar 读取上次缓存的数据渲染
- 数据校验：后台静默发起 Supabase 请求，对比数据版本
- 数据更新：如有新数据，无感替换旧数据（尽量避免布局跳动）

## 分页与懒加载

**规则**: 数据量超过 1000 条时，必须使用分页策略。

**实现模式**:
```dart
@riverpod
class PaginatedTodoList extends _$PaginatedTodoList {
  @override
  FutureOr<List<Todo>> build() async {
    return ref.watch(todoRepositoryProvider).getPage(offset: 0, limit: 20);
  }
  
  Future<void> loadMore() async {
    final current = await future;
    final next = await ref.read(todoRepositoryProvider).getPage(
      offset: current.length,
      limit: 20,
    );
    state = AsyncValue.data([...current, ...next]);
  }
}
```

**无限滚动**: 使用 `ListView.builder` + `ScrollController` 实现。

## 布局零偏移

**规则**: 数据加载前后，核心容器高度应保持稳定。

**实现**:
- 使用 Skeleton (骨架屏) 占位
- 或固定最小高度 (`min-height`) 占位
- 禁止内容加载导致的页面剧烈抖动

详见: [乐观更新](./乐观更新.md) | [数据同步](./数据同步.md)


