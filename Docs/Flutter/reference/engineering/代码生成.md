# 代码生成

**核心原则：减少样板代码 (Reduce Boilerplate) · 保证一致性 (Ensure Consistency)**

## Riverpod 代码生成

**配置**: `build.yaml`

**命令**: `dart run build_runner watch -d` (开发时常驻)

**生成内容**:
- Provider 实现代码
- 类型安全的 Provider 引用

## Freezed 代码生成

**使用**: 为所有 Entity 和 Model 使用 `@freezed` 注解

**生成内容**:
- `copyWith` 方法
- `toString`、`==`、`hashCode` 实现
- JSON 序列化代码（配合 `json_serializable`）

**示例**:
```dart
@freezed
class Todo with _$Todo {
  const factory Todo({
    required String id,
    required String title,
    @Default(false) bool done,
  }) = _Todo;
  
  factory Todo.fromJson(Map<String, dynamic> json) => _$TodoFromJson(json);
}
```

## OpenAPI 代码生成

**核心原则**: Schema-Driven Development，后端接口变更导致编译时错误而非运行时错误。

**要求**: 后端必须提供 OpenAPI (Swagger) 规范文件。

**使用**: 使用 `openapi_generator` 从 OpenAPI 规范自动生成 API Client 和 Models

**生成内容**:
- API 客户端类（基于 Dio）
- 请求/响应模型（自动生成 Freezed 兼容的模型）
- 类型安全的 API 方法

**工作流**:
1. 后端提供 OpenAPI 规范文件（`openapi.yaml` 或 `openapi.json`）
2. 运行代码生成命令生成 API Client
3. 生成的代码位于 `lib/generated/api/` 目录

**配置示例**:
```yaml
# openapi-generator-config.yaml
generatorName: dart
inputSpec: openapi.yaml
outputDir: lib/generated/api
```

**命令**:
```bash
# 安装 openapi_generator (如果使用 Dart 版本)
dart pub global activate openapi_generator

# 生成 API 客户端
openapi-generator generate -i openapi.yaml -g dart -o lib/generated/api
```

**与 Retrofit 的关系**:
- **优先使用 OpenAPI 生成**: 所有新接口应通过 OpenAPI 规范生成
- **Retrofit 作为后备**: 仅在以下情况使用 Retrofit 手动定义：
  - 遗留接口尚未纳入 OpenAPI 规范
  - 特殊的自定义请求逻辑（需在迁移完成后纳入 OpenAPI）

## Retrofit 代码生成

**使用**: 为 API 客户端使用 `@RestApi` 注解（仅作为 OpenAPI 的后备方案）

**生成内容**:
- API 请求方法实现
- 类型安全的请求/响应模型

**示例**:
```dart
@RestApi()
abstract class TodoApi {
  factory TodoApi(Dio dio) = _TodoApi;
  
  @GET('/todos')
  Future<List<Todo>> getTodos();
  
  @POST('/todos')
  Future<Todo> createTodo(@Body() Todo todo);
}
```

> **注意**: 新接口应优先使用 OpenAPI 代码生成，Retrofit 仅用于遗留接口或特殊场景。

## 代码生成工作流

**开发时**: `dart run build_runner watch --delete-conflicting-outputs`

**提交前**: `dart run build_runner build --delete-conflicting-outputs`

**CI/CD**: `dart run build_runner build --delete-conflicting-outputs`

详见: [构建工作流](./构建工作流.md) | [架构守护](./架构守护.md)


